{"ast":null,"code":"'use strict';\n\nvar inspect = require('object-inspect');\n\nvar $TypeError = require('es-errors/type');\n/*\n* This function traverses the list returning the node corresponding to the given key.\n*\n* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.\n* By doing so, all the recently used nodes can be accessed relatively quickly.\n*/\n\n/** @type {import('./list.d.ts').listGetNode} */\n// eslint-disable-next-line consistent-return\n\n\nvar listGetNode = function (list, key, isDelete) {\n  /** @type {typeof list | NonNullable<(typeof list)['next']>} */\n  var prev = list;\n  /** @type {(typeof list)['next']} */\n\n  var curr; // eslint-disable-next-line eqeqeq\n\n  for (; (curr = prev.next) != null; prev = curr) {\n    if (curr.key === key) {\n      prev.next = curr.next;\n\n      if (!isDelete) {\n        // eslint-disable-next-line no-extra-parens\n        curr.next =\n        /** @type {NonNullable<typeof list.next>} */\n        list.next;\n        list.next = curr; // eslint-disable-line no-param-reassign\n      }\n\n      return curr;\n    }\n  }\n};\n/** @type {import('./list.d.ts').listGet} */\n\n\nvar listGet = function (objects, key) {\n  if (!objects) {\n    return void undefined;\n  }\n\n  var node = listGetNode(objects, key);\n  return node && node.value;\n};\n/** @type {import('./list.d.ts').listSet} */\n\n\nvar listSet = function (objects, key, value) {\n  var node = listGetNode(objects, key);\n\n  if (node) {\n    node.value = value;\n  } else {\n    // Prepend the new node to the beginning of the list\n    objects.next =\n    /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */\n    {\n      // eslint-disable-line no-param-reassign, no-extra-parens\n      key: key,\n      next: objects.next,\n      value: value\n    };\n  }\n};\n/** @type {import('./list.d.ts').listHas} */\n\n\nvar listHas = function (objects, key) {\n  if (!objects) {\n    return false;\n  }\n\n  return !!listGetNode(objects, key);\n};\n/** @type {import('./list.d.ts').listDelete} */\n// eslint-disable-next-line consistent-return\n\n\nvar listDelete = function (objects, key) {\n  if (objects) {\n    return listGetNode(objects, key, true);\n  }\n};\n/** @type {import('.')} */\n\n\nmodule.exports = function getSideChannelList() {\n  /** @typedef {ReturnType<typeof getSideChannelList>} Channel */\n\n  /** @typedef {Parameters<Channel['get']>[0]} K */\n\n  /** @typedef {Parameters<Channel['set']>[1]} V */\n\n  /** @type {import('./list.d.ts').RootNode<V, K> | undefined} */\n  var $o;\n  /** @type {Channel} */\n\n  var channel = {\n    assert: function (key) {\n      if (!channel.has(key)) {\n        throw new $TypeError('Side channel does not contain ' + inspect(key));\n      }\n    },\n    'delete': function (key) {\n      var root = $o && $o.next;\n      var deletedNode = listDelete($o, key);\n\n      if (deletedNode && root && root === deletedNode) {\n        $o = void undefined;\n      }\n\n      return !!deletedNode;\n    },\n    get: function (key) {\n      return listGet($o, key);\n    },\n    has: function (key) {\n      return listHas($o, key);\n    },\n    set: function (key, value) {\n      if (!$o) {\n        // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head\n        $o = {\n          next: void undefined\n        };\n      } // eslint-disable-next-line no-extra-parens\n\n\n      listSet(\n      /** @type {NonNullable<typeof $o>} */\n      $o, key, value);\n    }\n  }; // @ts-expect-error TODO: figure out why this is erroring\n\n  return channel;\n};","map":null,"metadata":{},"sourceType":"script"}